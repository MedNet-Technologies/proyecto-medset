"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _jestMockPromise = _interopRequireDefault(require("jest-mock-promise"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _require = require('stream'),
    PassThrough = _require.PassThrough;

/** a FIFO queue of pending request */
var _pending_requests = [];

var _newReq = function _newReq(resource, init) {
  var promise = new _jestMockPromise["default"]();

  _pending_requests.push({
    init: init,
    promise: promise,
    resource: resource
  });

  return promise;
};
/** `fetch` is called like a function, that's why we're defining it as a spy */


var MockFetch = jest.fn(_newReq);
/**
 * (LEGACY) Removes the give promise from the queue OR last promise if none was suppiled
 * @param promise
 */

MockFetch.popPromise = function (promise) {
  console.warn("MockFetch.popPromise is a legacy method - please use `MockFetch.popQueueItem` instead");
  var queueItem = MockFetch.popQueueItem(promise);
  return queueItem === null || queueItem === void 0 ? void 0 : queueItem.promise;
};
/**
 * (LEGACY) Removes the give request from the queue OR last item if none was suppiled
 * @param item
 */


MockFetch.popRequest = function (item) {
  console.warn("MockFetch.popRequest is a legacy method - please use `MockFetch.popQueueItem` instead");
  var queueItem = MockFetch.popQueueItem(item);
  return queueItem;
};
/**
 * Removes an item form the queue
 * @param requestOrPromise (optional) which queue item to remove (can be specified by given promise)
 */


MockFetch.popQueueItem = function (requestOrPromise) {
  if (requestOrPromise) {
    var ix = _pending_requests.indexOf(requestOrPromise); // IF request is not found
    // > try searching for element by promise


    if (ix === -1) {
      ix = _pending_requests.findIndex(function (_ref) {
        var promise = _ref.promise;
        return promise === requestOrPromise;
      });
    }

    if (ix === -1) {
      return;
    }

    return _pending_requests.splice(ix, 1)[0];
  } else {
    // return the last element
    return _pending_requests.shift();
  }
};
/**
 * Simulate a server response, (optionally) with the given data
 * @param responseObject (optional) response returned by the server
 * @param queueItem (optional) request promise for which response should be resolved
 * @param silentMode (optional) specifies whether the call should throw an error or
 *   only fail quietly if no matching request is found.
 */


MockFetch.mockResponse = function (responseObject, item) {
  var silentMode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var request = MockFetch.popQueueItem(item);

  if (!request && !silentMode) {
    throw new Error("No request to respond to!");
  } else if (!request) {
    return;
  }

  var _ref2 = request,
      promise = _ref2.promise,
      resource = _ref2.resource;
  var responseDefaults = {
    body: new PassThrough(),
    headers: new Headers(),
    status: 200,
    statusText: "OK",
    ok: true,
    url: resource,
    arrayBuffer: function arrayBuffer() {
      return new ArrayBuffer(0);
    },
    blob: function blob() {
      return new Blob();
    },
    clone: jest.fn(),
    error: jest.fn(),
    formData: function formData() {
      return new FormData();
    },
    json: function json() {
      return {};
    },
    redirect: jest.fn(),
    text: function text() {
      return "dummy text";
    }
  };

  var actualResponse = _objectSpread(_objectSpread({}, responseDefaults), responseObject);

  promise.resolve(actualResponse);
  return actualResponse;
};

MockFetch.mockError = function () {
  var error = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var item = arguments.length > 1 ? arguments[1] : undefined;
  var silentMode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var request = MockFetch.popQueueItem(item);

  if (!request && !silentMode) {
    throw new Error("No request to respond to!");
  } else if (!request) {
    return;
  }

  var promise = request.promise; // resolving the Promise with the given response data

  promise.reject(error);
};

MockFetch.lastReqGet = function () {
  return _pending_requests[_pending_requests.length - 1];
};

MockFetch.lastPromiseGet = function () {
  var req = MockFetch.lastReqGet();
  return req ? req.promise : void 0;
};

MockFetch.getReqByUrl = function (resource) {
  return _pending_requests.slice().reverse() // reverse cloned array to return most recent req
  .find(function (x) {
    return x.resource === resource;
  });
};

MockFetch.reset = function () {
  // remove all the requests
  _pending_requests.splice(0, _pending_requests.length);
}; // this is a singleton object


var _default = MockFetch;
exports["default"] = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL2xpYi9tb2NrLWZldGNoLnRzIl0sIm5hbWVzIjpbInJlcXVpcmUiLCJQYXNzVGhyb3VnaCIsIl9wZW5kaW5nX3JlcXVlc3RzIiwiX25ld1JlcSIsInJlc291cmNlIiwiaW5pdCIsInByb21pc2UiLCJKZXN0TW9ja1Byb21pc2UiLCJwdXNoIiwiTW9ja0ZldGNoIiwiamVzdCIsImZuIiwicG9wUHJvbWlzZSIsImNvbnNvbGUiLCJ3YXJuIiwicXVldWVJdGVtIiwicG9wUXVldWVJdGVtIiwicG9wUmVxdWVzdCIsIml0ZW0iLCJyZXF1ZXN0T3JQcm9taXNlIiwiaXgiLCJpbmRleE9mIiwiZmluZEluZGV4Iiwic3BsaWNlIiwic2hpZnQiLCJtb2NrUmVzcG9uc2UiLCJyZXNwb25zZU9iamVjdCIsInNpbGVudE1vZGUiLCJyZXF1ZXN0IiwiRXJyb3IiLCJyZXNwb25zZURlZmF1bHRzIiwiYm9keSIsImhlYWRlcnMiLCJIZWFkZXJzIiwic3RhdHVzIiwic3RhdHVzVGV4dCIsIm9rIiwidXJsIiwiYXJyYXlCdWZmZXIiLCJBcnJheUJ1ZmZlciIsImJsb2IiLCJCbG9iIiwiY2xvbmUiLCJlcnJvciIsImZvcm1EYXRhIiwiRm9ybURhdGEiLCJqc29uIiwicmVkaXJlY3QiLCJ0ZXh0IiwiYWN0dWFsUmVzcG9uc2UiLCJyZXNvbHZlIiwibW9ja0Vycm9yIiwicmVqZWN0IiwibGFzdFJlcUdldCIsImxlbmd0aCIsImxhc3RQcm9taXNlR2V0IiwicmVxIiwiZ2V0UmVxQnlVcmwiLCJzbGljZSIsInJldmVyc2UiLCJmaW5kIiwieCIsInJlc2V0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBT0E7Ozs7Ozs7Ozs7QUFDQSxlQUF3QkEsT0FBTyxDQUFDLFFBQUQsQ0FBL0I7QUFBQSxJQUFRQyxXQUFSLFlBQVFBLFdBQVI7O0FBU0E7QUFDQSxJQUFNQyxpQkFBdUMsR0FBRyxFQUFoRDs7QUFFQSxJQUFNQyxPQUFzRSxHQUFHLFNBQXpFQSxPQUF5RSxDQUFDQyxRQUFELEVBQVdDLElBQVgsRUFBb0I7QUFFL0YsTUFBTUMsT0FBd0IsR0FBRyxJQUFJQywyQkFBSixFQUFqQzs7QUFFQUwsRUFBQUEsaUJBQWlCLENBQUNNLElBQWxCLENBQXVCO0FBQ25CSCxJQUFBQSxJQUFJLEVBQUpBLElBRG1CO0FBRW5CQyxJQUFBQSxPQUFPLEVBQVBBLE9BRm1CO0FBR25CRixJQUFBQSxRQUFRLEVBQVJBO0FBSG1CLEdBQXZCOztBQU1BLFNBQU9FLE9BQVA7QUFDSCxDQVhEO0FBYUE7OztBQUNBLElBQU1HLFNBQXdCLEdBQUlDLElBQUksQ0FBQ0MsRUFBTCxDQUFRUixPQUFSLENBQWxDO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0FNLFNBQVMsQ0FBQ0csVUFBVixHQUF1QixVQUFDTixPQUFELEVBQTJEO0FBQzlFTyxFQUFBQSxPQUFPLENBQUNDLElBQVIsQ0FBYSx1RkFBYjtBQUNBLE1BQU1DLFNBQVMsR0FBR04sU0FBUyxDQUFDTyxZQUFWLENBQXVCVixPQUF2QixDQUFsQjtBQUNBLFNBQU9TLFNBQVAsYUFBT0EsU0FBUCx1QkFBT0EsU0FBUyxDQUFFVCxPQUFsQjtBQUNILENBSkQ7QUFNQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0FHLFNBQVMsQ0FBQ1EsVUFBVixHQUF1QixVQUFDQyxJQUFELEVBQThEO0FBQ2pGTCxFQUFBQSxPQUFPLENBQUNDLElBQVIsQ0FBYSx1RkFBYjtBQUNBLE1BQU1DLFNBQVMsR0FBR04sU0FBUyxDQUFDTyxZQUFWLENBQXVCRSxJQUF2QixDQUFsQjtBQUNBLFNBQU9ILFNBQVA7QUFDSCxDQUpEO0FBTUE7QUFDQTtBQUNBO0FBQ0E7OztBQUNDTixTQUFTLENBQUNPLFlBQVYsR0FBeUIsVUFBQ0csZ0JBQUQsRUFBNkY7QUFDbkgsTUFBSUEsZ0JBQUosRUFBc0I7QUFFbEIsUUFBSUMsRUFBRSxHQUFHbEIsaUJBQWlCLENBQUNtQixPQUFsQixDQUEwQkYsZ0JBQTFCLENBQVQsQ0FGa0IsQ0FJbEI7QUFDQTs7O0FBQ0EsUUFBSUMsRUFBRSxLQUFLLENBQUMsQ0FBWixFQUFlO0FBQ1hBLE1BQUFBLEVBQUUsR0FBR2xCLGlCQUFpQixDQUFDb0IsU0FBbEIsQ0FBNEI7QUFBQSxZQUFFaEIsT0FBRixRQUFFQSxPQUFGO0FBQUEsZUFBZUEsT0FBTyxLQUFLYSxnQkFBM0I7QUFBQSxPQUE1QixDQUFMO0FBQ0g7O0FBRUQsUUFBR0MsRUFBRSxLQUFLLENBQUMsQ0FBWCxFQUFjO0FBQ1Y7QUFDSDs7QUFFRCxXQUFPbEIsaUJBQWlCLENBQUNxQixNQUFsQixDQUF5QkgsRUFBekIsRUFBNkIsQ0FBN0IsRUFBZ0MsQ0FBaEMsQ0FBUDtBQUVILEdBaEJELE1BZ0JPO0FBRUg7QUFDQSxXQUFPbEIsaUJBQWlCLENBQUNzQixLQUFsQixFQUFQO0FBQ0g7QUFDSixDQXRCQTtBQXdCRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0lmLFNBQVMsQ0FBQ2dCLFlBQVYsR0FBeUIsVUFDekJDLGNBRHlCLEVBRXpCUixJQUZ5QixFQUlFO0FBQUEsTUFEM0JTLFVBQzJCLHVFQURMLEtBQ0s7QUFFM0IsTUFBTUMsT0FBTyxHQUFHbkIsU0FBUyxDQUFDTyxZQUFWLENBQXVCRSxJQUF2QixDQUFoQjs7QUFFQSxNQUFJLENBQUNVLE9BQUQsSUFBWSxDQUFDRCxVQUFqQixFQUE2QjtBQUN6QixVQUFNLElBQUlFLEtBQUosQ0FBVSwyQkFBVixDQUFOO0FBQ0gsR0FGRCxNQUVPLElBQUksQ0FBQ0QsT0FBTCxFQUFjO0FBQ2pCO0FBQ0g7O0FBRUQsY0FBOEJBLE9BQTlCO0FBQUEsTUFBUXRCLE9BQVIsU0FBUUEsT0FBUjtBQUFBLE1BQWlCRixRQUFqQixTQUFpQkEsUUFBakI7QUFFQSxNQUFNMEIsZ0JBQTZCLEdBQUc7QUFDbENDLElBQUFBLElBQUksRUFBRSxJQUFJOUIsV0FBSixFQUQ0QjtBQUVsQytCLElBQUFBLE9BQU8sRUFBRSxJQUFJQyxPQUFKLEVBRnlCO0FBR2xDQyxJQUFBQSxNQUFNLEVBQUUsR0FIMEI7QUFJbENDLElBQUFBLFVBQVUsRUFBRSxJQUpzQjtBQUtsQ0MsSUFBQUEsRUFBRSxFQUFFLElBTDhCO0FBTWxDQyxJQUFBQSxHQUFHLEVBQUVqQyxRQU42QjtBQU9sQ2tDLElBQUFBLFdBQVcsRUFBRTtBQUFBLGFBQU0sSUFBSUMsV0FBSixDQUFnQixDQUFoQixDQUFOO0FBQUEsS0FQcUI7QUFRbENDLElBQUFBLElBQUksRUFBRTtBQUFBLGFBQU0sSUFBSUMsSUFBSixFQUFOO0FBQUEsS0FSNEI7QUFTbENDLElBQUFBLEtBQUssRUFBRWhDLElBQUksQ0FBQ0MsRUFBTCxFQVQyQjtBQVVsQ2dDLElBQUFBLEtBQUssRUFBRWpDLElBQUksQ0FBQ0MsRUFBTCxFQVYyQjtBQVdsQ2lDLElBQUFBLFFBQVEsRUFBRTtBQUFBLGFBQU0sSUFBSUMsUUFBSixFQUFOO0FBQUEsS0FYd0I7QUFZbENDLElBQUFBLElBQUksRUFBRTtBQUFBLGFBQU8sRUFBUDtBQUFBLEtBWjRCO0FBYWxDQyxJQUFBQSxRQUFRLEVBQUVyQyxJQUFJLENBQUNDLEVBQUwsRUFid0I7QUFjbENxQyxJQUFBQSxJQUFJLEVBQUU7QUFBQSxhQUFNLFlBQU47QUFBQTtBQWQ0QixHQUF0Qzs7QUFpQkEsTUFBTUMsY0FBMkIsbUNBQzFCbkIsZ0JBRDBCLEdBRzFCSixjQUgwQixDQUFqQzs7QUFNQXBCLEVBQUFBLE9BQU8sQ0FBQzRDLE9BQVIsQ0FBZ0JELGNBQWhCO0FBRUEsU0FBT0EsY0FBUDtBQUNILENBMUNHOztBQTRDSnhDLFNBQVMsQ0FBQzBDLFNBQVYsR0FBc0IsWUFJakI7QUFBQSxNQUhEUixLQUdDLHVFQUhZLEVBR1o7QUFBQSxNQUZEekIsSUFFQztBQUFBLE1BRERTLFVBQ0MsdUVBRHFCLEtBQ3JCO0FBRUQsTUFBTUMsT0FBTyxHQUFHbkIsU0FBUyxDQUFDTyxZQUFWLENBQXVCRSxJQUF2QixDQUFoQjs7QUFFQSxNQUFJLENBQUNVLE9BQUQsSUFBWSxDQUFDRCxVQUFqQixFQUE2QjtBQUN6QixVQUFNLElBQUlFLEtBQUosQ0FBVSwyQkFBVixDQUFOO0FBQ0gsR0FGRCxNQUVPLElBQUksQ0FBQ0QsT0FBTCxFQUFjO0FBQ2pCO0FBQ0g7O0FBRUQsTUFBUXRCLE9BQVIsR0FBb0JzQixPQUFwQixDQUFRdEIsT0FBUixDQVZDLENBWUQ7O0FBQ0FBLEVBQUFBLE9BQU8sQ0FBQzhDLE1BQVIsQ0FBZVQsS0FBZjtBQUNILENBbEJEOztBQW9CQWxDLFNBQVMsQ0FBQzRDLFVBQVYsR0FBdUIsWUFBTTtBQUN6QixTQUFPbkQsaUJBQWlCLENBQUNBLGlCQUFpQixDQUFDb0QsTUFBbEIsR0FBMkIsQ0FBNUIsQ0FBeEI7QUFDSCxDQUZEOztBQUlBN0MsU0FBUyxDQUFDOEMsY0FBVixHQUEyQixZQUFNO0FBQzdCLE1BQU1DLEdBQUcsR0FBRy9DLFNBQVMsQ0FBQzRDLFVBQVYsRUFBWjtBQUNBLFNBQU9HLEdBQUcsR0FBR0EsR0FBRyxDQUFDbEQsT0FBUCxHQUFpQixLQUFLLENBQWhDO0FBQ0gsQ0FIRDs7QUFLQUcsU0FBUyxDQUFDZ0QsV0FBVixHQUF3QixVQUFDckQsUUFBRCxFQUEyQjtBQUMvQyxTQUFPRixpQkFBaUIsQ0FDbkJ3RCxLQURFLEdBRUZDLE9BRkUsR0FFUTtBQUZSLEdBR0ZDLElBSEUsQ0FHRyxVQUFDQyxDQUFEO0FBQUEsV0FBMkJBLENBQUMsQ0FBQ3pELFFBQUYsS0FBZUEsUUFBMUM7QUFBQSxHQUhILENBQVA7QUFJSCxDQUxEOztBQU9BSyxTQUFTLENBQUNxRCxLQUFWLEdBQWtCLFlBQU07QUFDcEI7QUFDQTVELEVBQUFBLGlCQUFpQixDQUFDcUIsTUFBbEIsQ0FBeUIsQ0FBekIsRUFBNEJyQixpQkFBaUIsQ0FBQ29ELE1BQTlDO0FBQ0gsQ0FIRCxDLENBS0E7OztlQUNlN0MsUyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVHlwZVNjcmlwdCB2ZXJzaW9uIG9mIGBmZXRjaGAgbW9jayBmb3IgdW5pdCB0ZXN0aW5nIHdpdGggW0plc3RdKGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL2plc3QvKS5cbiAqXG4gKiBAYXV0aG9yICAga25lZS1jb2xhIDxuaWtvbGEuZGVyZXppY0BnbWFpbC5jb20+XG4gKiBAbGljZW5zZSAgQGxpY2Vuc2UgTUlUIExpY2Vuc2UsIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXG4gKi9cblxuaW1wb3J0IEplc3RNb2NrUHJvbWlzZSBmcm9tIFwiamVzdC1tb2NrLXByb21pc2VcIjtcbmNvbnN0IHsgUGFzc1Rocm91Z2ggfSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuXG5pbXBvcnQge1xuICAgIEZldGNoTW9ja1F1ZXVlSXRlbSxcbiAgICBGZXRjaE1vY2tUeXBlLFxuICAgIEh0dHBSZXNwb25zZSxcbiAgICBIdHRwUmVzcG9uc2VQYXJ0aWFsLFxufSBmcm9tIFwiLi9tb2NrLWZldGNoLXR5cGVzXCI7XG5cbi8qKiBhIEZJRk8gcXVldWUgb2YgcGVuZGluZyByZXF1ZXN0ICovXG5jb25zdCBfcGVuZGluZ19yZXF1ZXN0czogRmV0Y2hNb2NrUXVldWVJdGVtW10gPSBbXTtcblxuY29uc3QgX25ld1JlcTogKHJlc291cmNlOiBSZXF1ZXN0SW5mbywgaW5pdD86UmVxdWVzdEluaXQpID0+IEplc3RNb2NrUHJvbWlzZSA9IChyZXNvdXJjZSwgaW5pdCkgPT4ge1xuXG4gICAgY29uc3QgcHJvbWlzZTogSmVzdE1vY2tQcm9taXNlID0gbmV3IEplc3RNb2NrUHJvbWlzZSgpO1xuXG4gICAgX3BlbmRpbmdfcmVxdWVzdHMucHVzaCh7XG4gICAgICAgIGluaXQsXG4gICAgICAgIHByb21pc2UsXG4gICAgICAgIHJlc291cmNlLFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHByb21pc2U7XG59O1xuXG4vKiogYGZldGNoYCBpcyBjYWxsZWQgbGlrZSBhIGZ1bmN0aW9uLCB0aGF0J3Mgd2h5IHdlJ3JlIGRlZmluaW5nIGl0IGFzIGEgc3B5ICovXG5jb25zdCBNb2NrRmV0Y2g6IEZldGNoTW9ja1R5cGUgPSAoamVzdC5mbihfbmV3UmVxKSBhcyB1bmtub3duKSBhcyBGZXRjaE1vY2tUeXBlO1xuXG4vKipcbiAqIChMRUdBQ1kpIFJlbW92ZXMgdGhlIGdpdmUgcHJvbWlzZSBmcm9tIHRoZSBxdWV1ZSBPUiBsYXN0IHByb21pc2UgaWYgbm9uZSB3YXMgc3VwcGlsZWRcbiAqIEBwYXJhbSBwcm9taXNlXG4gKi9cbk1vY2tGZXRjaC5wb3BQcm9taXNlID0gKHByb21pc2U/OiBKZXN0TW9ja1Byb21pc2UpOkplc3RNb2NrUHJvbWlzZSB8IHVuZGVmaW5lZCA9PiB7XG4gICAgY29uc29sZS53YXJuKFwiTW9ja0ZldGNoLnBvcFByb21pc2UgaXMgYSBsZWdhY3kgbWV0aG9kIC0gcGxlYXNlIHVzZSBgTW9ja0ZldGNoLnBvcFF1ZXVlSXRlbWAgaW5zdGVhZFwiKTtcbiAgICBjb25zdCBxdWV1ZUl0ZW0gPSBNb2NrRmV0Y2gucG9wUXVldWVJdGVtKHByb21pc2UpO1xuICAgIHJldHVybihxdWV1ZUl0ZW0/LnByb21pc2UpO1xufVxuXG4vKipcbiAqIChMRUdBQ1kpIFJlbW92ZXMgdGhlIGdpdmUgcmVxdWVzdCBmcm9tIHRoZSBxdWV1ZSBPUiBsYXN0IGl0ZW0gaWYgbm9uZSB3YXMgc3VwcGlsZWRcbiAqIEBwYXJhbSBpdGVtXG4gKi9cbk1vY2tGZXRjaC5wb3BSZXF1ZXN0ID0gKGl0ZW0/OiBGZXRjaE1vY2tRdWV1ZUl0ZW0pOkZldGNoTW9ja1F1ZXVlSXRlbSB8IHVuZGVmaW5lZCA9PiB7XG4gICAgY29uc29sZS53YXJuKFwiTW9ja0ZldGNoLnBvcFJlcXVlc3QgaXMgYSBsZWdhY3kgbWV0aG9kIC0gcGxlYXNlIHVzZSBgTW9ja0ZldGNoLnBvcFF1ZXVlSXRlbWAgaW5zdGVhZFwiKTtcbiAgICBjb25zdCBxdWV1ZUl0ZW0gPSBNb2NrRmV0Y2gucG9wUXVldWVJdGVtKGl0ZW0pO1xuICAgIHJldHVybihxdWV1ZUl0ZW0pO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGFuIGl0ZW0gZm9ybSB0aGUgcXVldWVcbiAqIEBwYXJhbSByZXF1ZXN0T3JQcm9taXNlIChvcHRpb25hbCkgd2hpY2ggcXVldWUgaXRlbSB0byByZW1vdmUgKGNhbiBiZSBzcGVjaWZpZWQgYnkgZ2l2ZW4gcHJvbWlzZSlcbiAqL1xuIE1vY2tGZXRjaC5wb3BRdWV1ZUl0ZW0gPSAocmVxdWVzdE9yUHJvbWlzZT86IEZldGNoTW9ja1F1ZXVlSXRlbSB8IEplc3RNb2NrUHJvbWlzZSk6IEZldGNoTW9ja1F1ZXVlSXRlbSB8IHVuZGVmaW5lZCA9PiB7XG4gICAgaWYgKHJlcXVlc3RPclByb21pc2UpIHtcblxuICAgICAgICBsZXQgaXggPSBfcGVuZGluZ19yZXF1ZXN0cy5pbmRleE9mKHJlcXVlc3RPclByb21pc2UgYXMgRmV0Y2hNb2NrUXVldWVJdGVtKTtcblxuICAgICAgICAvLyBJRiByZXF1ZXN0IGlzIG5vdCBmb3VuZFxuICAgICAgICAvLyA+IHRyeSBzZWFyY2hpbmcgZm9yIGVsZW1lbnQgYnkgcHJvbWlzZVxuICAgICAgICBpZiAoaXggPT09IC0xKSB7XG4gICAgICAgICAgICBpeCA9IF9wZW5kaW5nX3JlcXVlc3RzLmZpbmRJbmRleCgoe3Byb21pc2V9KSA9PiBwcm9taXNlID09PSByZXF1ZXN0T3JQcm9taXNlIGFzIEplc3RNb2NrUHJvbWlzZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZihpeCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybjsgICAgICAgICAgICAgICAgXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4oX3BlbmRpbmdfcmVxdWVzdHMuc3BsaWNlKGl4LCAxKVswXSk7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8vIHJldHVybiB0aGUgbGFzdCBlbGVtZW50XG4gICAgICAgIHJldHVybiBfcGVuZGluZ19yZXF1ZXN0cy5zaGlmdCgpO1xuICAgIH1cbn07XG5cbi8qKlxuICogU2ltdWxhdGUgYSBzZXJ2ZXIgcmVzcG9uc2UsIChvcHRpb25hbGx5KSB3aXRoIHRoZSBnaXZlbiBkYXRhXG4gKiBAcGFyYW0gcmVzcG9uc2VPYmplY3QgKG9wdGlvbmFsKSByZXNwb25zZSByZXR1cm5lZCBieSB0aGUgc2VydmVyXG4gKiBAcGFyYW0gcXVldWVJdGVtIChvcHRpb25hbCkgcmVxdWVzdCBwcm9taXNlIGZvciB3aGljaCByZXNwb25zZSBzaG91bGQgYmUgcmVzb2x2ZWRcbiAqIEBwYXJhbSBzaWxlbnRNb2RlIChvcHRpb25hbCkgc3BlY2lmaWVzIHdoZXRoZXIgdGhlIGNhbGwgc2hvdWxkIHRocm93IGFuIGVycm9yIG9yXG4gKiAgIG9ubHkgZmFpbCBxdWlldGx5IGlmIG5vIG1hdGNoaW5nIHJlcXVlc3QgaXMgZm91bmQuXG4gKi9cbiAgICBNb2NrRmV0Y2gubW9ja1Jlc3BvbnNlID0gKFxuICAgIHJlc3BvbnNlT2JqZWN0PzogSHR0cFJlc3BvbnNlUGFydGlhbCxcbiAgICBpdGVtPzogRmV0Y2hNb2NrUXVldWVJdGVtIHwgSmVzdE1vY2tQcm9taXNlLFxuICAgIHNpbGVudE1vZGU6IGJvb2xlYW4gPSBmYWxzZSxcbik6IEh0dHBSZXNwb25zZSB8IHVuZGVmaW5lZCA9PiB7XG5cbiAgICBjb25zdCByZXF1ZXN0ID0gTW9ja0ZldGNoLnBvcFF1ZXVlSXRlbShpdGVtKTtcblxuICAgIGlmICghcmVxdWVzdCAmJiAhc2lsZW50TW9kZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyByZXF1ZXN0IHRvIHJlc3BvbmQgdG8hXCIpO1xuICAgIH0gZWxzZSBpZiAoIXJlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHsgcHJvbWlzZSwgcmVzb3VyY2UgfSA9IHJlcXVlc3QgYXMgRmV0Y2hNb2NrUXVldWVJdGVtO1xuXG4gICAgY29uc3QgcmVzcG9uc2VEZWZhdWx0czpIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgIGJvZHk6IG5ldyBQYXNzVGhyb3VnaCgpLFxuICAgICAgICBoZWFkZXJzOiBuZXcgSGVhZGVycygpLFxuICAgICAgICBzdGF0dXM6IDIwMCxcbiAgICAgICAgc3RhdHVzVGV4dDogXCJPS1wiLFxuICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAgdXJsOiByZXNvdXJjZSBhcyBzdHJpbmcsXG4gICAgICAgIGFycmF5QnVmZmVyOiAoKSA9PiBuZXcgQXJyYXlCdWZmZXIoMCksXG4gICAgICAgIGJsb2I6ICgpID0+IG5ldyBCbG9iKCksXG4gICAgICAgIGNsb25lOiBqZXN0LmZuKCksXG4gICAgICAgIGVycm9yOiBqZXN0LmZuKCksXG4gICAgICAgIGZvcm1EYXRhOiAoKSA9PiBuZXcgRm9ybURhdGEoKSxcbiAgICAgICAganNvbjogKCkgPT4gKHsgfSksXG4gICAgICAgIHJlZGlyZWN0OiBqZXN0LmZuKCksXG4gICAgICAgIHRleHQ6ICgpID0+IFwiZHVtbXkgdGV4dFwiXG4gICAgfTtcblxuICAgIGNvbnN0IGFjdHVhbFJlc3BvbnNlOkh0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgLi4ucmVzcG9uc2VEZWZhdWx0cyxcbiAgICAgICAgLy8gYWxsIHBhcmFtcyBjYW4gYmUgb3ZlcnJpZGVuIHZpYSB0aGUgYHJlc3BvbnNlT2JqZWN0YCBwYXJhbVxuICAgICAgICAuLi5yZXNwb25zZU9iamVjdFxuICAgIH1cblxuICAgIHByb21pc2UucmVzb2x2ZShhY3R1YWxSZXNwb25zZSk7XG5cbiAgICByZXR1cm4oYWN0dWFsUmVzcG9uc2UpO1xufTtcblxuTW9ja0ZldGNoLm1vY2tFcnJvciA9IChcbiAgICBlcnJvcjogYW55ID0ge30sXG4gICAgaXRlbT86IEZldGNoTW9ja1F1ZXVlSXRlbSB8IEplc3RNb2NrUHJvbWlzZSxcbiAgICBzaWxlbnRNb2RlOiBib29sZWFuID0gZmFsc2UsXG4pID0+IHtcblxuICAgIGNvbnN0IHJlcXVlc3QgPSBNb2NrRmV0Y2gucG9wUXVldWVJdGVtKGl0ZW0pO1xuXG4gICAgaWYgKCFyZXF1ZXN0ICYmICFzaWxlbnRNb2RlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHJlcXVlc3QgdG8gcmVzcG9uZCB0byFcIik7XG4gICAgfSBlbHNlIGlmICghcmVxdWVzdCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgeyBwcm9taXNlIH0gPSByZXF1ZXN0O1xuXG4gICAgLy8gcmVzb2x2aW5nIHRoZSBQcm9taXNlIHdpdGggdGhlIGdpdmVuIHJlc3BvbnNlIGRhdGFcbiAgICBwcm9taXNlLnJlamVjdChlcnJvcik7XG59O1xuXG5Nb2NrRmV0Y2gubGFzdFJlcUdldCA9ICgpID0+IHtcbiAgICByZXR1cm4gX3BlbmRpbmdfcmVxdWVzdHNbX3BlbmRpbmdfcmVxdWVzdHMubGVuZ3RoIC0gMV07XG59O1xuXG5Nb2NrRmV0Y2gubGFzdFByb21pc2VHZXQgPSAoKSA9PiB7XG4gICAgY29uc3QgcmVxID0gTW9ja0ZldGNoLmxhc3RSZXFHZXQoKTtcbiAgICByZXR1cm4gcmVxID8gcmVxLnByb21pc2UgOiB2b2lkIDA7XG59O1xuXG5Nb2NrRmV0Y2guZ2V0UmVxQnlVcmwgPSAocmVzb3VyY2U6IFJlcXVlc3RJbmZvKSA9PiB7XG4gICAgcmV0dXJuIF9wZW5kaW5nX3JlcXVlc3RzXG4gICAgICAgIC5zbGljZSgpXG4gICAgICAgIC5yZXZlcnNlKCkgLy8gcmV2ZXJzZSBjbG9uZWQgYXJyYXkgdG8gcmV0dXJuIG1vc3QgcmVjZW50IHJlcVxuICAgICAgICAuZmluZCgoeDogRmV0Y2hNb2NrUXVldWVJdGVtKSA9PiB4LnJlc291cmNlID09PSByZXNvdXJjZSk7XG59O1xuXG5Nb2NrRmV0Y2gucmVzZXQgPSAoKSA9PiB7XG4gICAgLy8gcmVtb3ZlIGFsbCB0aGUgcmVxdWVzdHNcbiAgICBfcGVuZGluZ19yZXF1ZXN0cy5zcGxpY2UoMCwgX3BlbmRpbmdfcmVxdWVzdHMubGVuZ3RoKTtcbn07XG5cbi8vIHRoaXMgaXMgYSBzaW5nbGV0b24gb2JqZWN0XG5leHBvcnQgZGVmYXVsdCBNb2NrRmV0Y2g7XG4iXX0=